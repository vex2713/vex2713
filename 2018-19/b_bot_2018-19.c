#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    teamSwitchPot,  sensorPotentiometer)
#pragma config(Sensor, in2,    gyro1,          sensorGyro)
#pragma config(Sensor, in3,    routineSwitchPot, sensorNone)
#pragma config(Sensor, I2C_1,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           frontLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rearLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           midLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           conveyor,      tmotorNone, openLoop)
#pragma config(Motor,  port5,           leftFlyWheels, tmotorNone, openLoop)
#pragma config(Motor,  port6,           rightFlyWheels, tmotorNone, openLoop)
#pragma config(Motor,  port7,           capFlip,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           midRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rearRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port10,          frontRight,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(bool,  port8,						teamSwitch,
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


//DL force sensor debugging

//#pragma DebuggerWindows("Sensors")
//#pragma DebuggerWindows("Globals")
//#pragma DebuggerWindows("Locals")



//DL 01/30/19


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//teamSwitch = true;
int defaultMotorSpeed;
float gyroCorrection = 0.8;

void pre_auton()
{
}
//beebot
//true is for blue, false is for red.
//between 708 and 4095


void stopMotor()
{
		motor[frontRight] = 0;
		motor[midRight] = 0;
		motor[rearRight] = 0;
		motor[frontLeft] = 0;
		motor[midLeft] = 0;
		motor[rearLeft] = 0;
	}


/**

void turnLeftByTime(int power, int duration)
{

		motor[frontRight] = power;
		motor[midRight] = power;
		motor[rearRight] = power;
		motor[frontLeft] = -1*power;
		motor[midLeft] = -1*power;
		motor[rearLeft] = -1*power;



		sleep(duration);
}

void turnRightByTime(int power, int duration)
{
		motor[frontRight] = -1*power;
		motor[midRight] = -1*power;
		motor[rearRight] = -1*power;
		motor[frontLeft] = power;
		motor[midLeft] = power;
		motor[rearLeft] = power;
				sleep(duration);
}


void goForwardByTime(int power, int duration)
{

		motor[frontRight] = power;
		motor[midRight] = power;
		motor[rearRight] = power;
		motor[frontLeft] = power;
		motor[midLeft] = power;
		motor[rearLeft] = power;


		//sleep is in msec
		sleep(duration);

}





void goBackByTime(int power, int duration)
{

		motor[frontRight] = -1*power;
		motor[midRight] = -1*power;
		motor[rearRight] = -1*power;
		motor[frontLeft] = -1*power;
		motor[midLeft] = -1*power;
		motor[rearLeft] = -1*power;



		sleep(duration);
}

**/


void goForwardDistance(int clicks)
{
	int power;
	power=defaultMotorSpeed;
			writeDebugStreamLine("starting goForwardDistance");
//	writeDebugStreamLine("enc left:%d",SensorValue[leftEncoder]);
//  writeDebugStreamLine("enc left:%d",clicks);


			SensorValue[leftEncoder]=0;



	while	(SensorValue[leftEncoder]<clicks)
	{
			//go forward for 1/10 second
		motor[frontRight] = power;
		motor[midRight] = power;
		motor[rearRight] = power;
		motor[frontLeft] = power;
		motor[midLeft] = power;
		motor[rearLeft] = power;
		sleep(100);

		}
			writeDebugStreamLine("ending goForwardDistance");
}


void goBackDistance(int clicks)
{
	int power;
	power=defaultMotorSpeed;
	writeDebugStreamLine("starting goBackDistance");
	SensorValue[leftEncoder]=0;
	while	(SensorValue[leftEncoder]>=-1*clicks)
	{
			//go back for 1/10 second
		motor[frontRight] = -1*power;
		motor[midRight] = -1*power;
		motor[rearRight] = -1*power;
		motor[frontLeft] = -1*power;
		motor[midLeft] = -1*power;
		motor[rearLeft] = -1*power;
		sleep(100);

		}
		writeDebugStreamLine("ending goBackDistance");

}
void goForwardInches(float inches)
{
	int power;
		int clicks;
	clicks=inches*50;

	power=defaultMotorSpeed;
			writeDebugStreamLine("starting goForwardDistance");
//	writeDebugStreamLine("enc left:%d",SensorValue[leftEncoder]);
//  writeDebugStreamLine("enc left:%d",clicks);


			SensorValue[leftEncoder]=0;



	while	(SensorValue[leftEncoder]<clicks)
	{
			//go forward for 1/10 second
		motor[frontRight] = power;
		motor[midRight] = power;
		motor[rearRight] = power;
		motor[frontLeft] = power;
		motor[midLeft] = power;
		motor[rearLeft] = power;
		sleep(100);

		}
			writeDebugStreamLine("ending goForwardDistance");
}


void goBackInches(float inches)
{
	int power;
	int clicks;
	clicks=inches*50;
	power=defaultMotorSpeed;
	writeDebugStreamLine("starting goBackDistance");
	SensorValue[leftEncoder]=0;
	while	(SensorValue[leftEncoder]>=-1*clicks)
	{
			//go back for 1/10 second
		motor[frontRight] = -1*power;
		motor[midRight] = -1*power;
		motor[rearRight] = -1*power;
		motor[frontLeft] = -1*power;
		motor[midLeft] = -1*power;
		motor[rearLeft] = -1*power;
		sleep(100);

		}
		writeDebugStreamLine("ending goBackDistance");

}


int inches2clicks()
{
}


void startFlyWheels()
{
			motor[leftFlyWheels] = 126;
			motor[rightFlyWheels] = -126;
}

void stopFlyWheels()
{
			motor[leftFlyWheels] = 0;
			motor[rightFlyWheels] = 0;


}


void fireRockets()
{
			motor[leftFlyWheels] = 126;
			motor[rightFlyWheels] = -126;
			sleep(2000);
			motor[conveyor] = 126;

			sleep(3000);


			motor[leftFlyWheels] = 0;
			motor[rightFlyWheels] = 0;
			motor[conveyor] = 0;
}
void launchBall(int power, int duration)
{
}

void putControlsForwardMode()
{
motor[frontRight] = vexRT[Ch2];
motor[midRight]   = vexRT[Ch2];
motor[rearRight]  = vexRT[Ch2];

motor[frontLeft] = vexRT[Ch3];
motor[midLeft] = vexRT[Ch3];
motor[rearLeft] = vexRT[Ch3];
}

void putControlsBackwardMode()
{
motor[frontRight] = -vexRT[Ch2];
motor[midRight]   = -vexRT[Ch2];
motor[rearRight]  = -vexRT[Ch2];

motor[frontLeft] = -vexRT[Ch3];
motor[midLeft] = -vexRT[Ch3];
motor[rearLeft] = -vexRT[Ch3];
}


void turnLeftByDegrees(int targetDegrees)
{
	int power=128;
		power=defaultMotorSpeed;
	SensorValue[gyro1]=0;
	while (abs(SensorValue[gyro1])<(targetDegrees*10*gyroCorrection))
	{
		motor[frontRight] = power;
		motor[midRight] = power;
		motor[rearRight] = power;
		motor[frontLeft] = -1*power;
		motor[midLeft] =  -1*power;
		motor[rearLeft] =  -1*power;
		sleep(100);
	}
}

void turnRightByDegrees(int targetDegrees)
{
	int power=128;
			power=defaultMotorSpeed;
		SensorValue[gyro1]=0;
	while (abs(SensorValue[gyro1])<(targetDegrees*10*gyroCorrection))
	{
		motor[frontRight] = -1*power;
		motor[midRight] = -1*power;
		motor[rearRight] = -1*power;
		motor[frontLeft] = power;
		motor[midLeft] =  power;
		motor[rearLeft] =  power;
		sleep(100);
	}
}

task autonomous_Blue_A()
{
}
task autonomous_Blue_B()
{

//assuming blue team, further from flag, want to hit the flag
//start facing toward the flag
	// we are red tream
	// will fire ball then go after caps



fireRockets();
//fireRockets();


goForwardInches(28);
goBackInches(36);
turnLeftByDegrees(90);
goForwardInches(36);
//motor[capFlip]=128;

//goBackInches(36);


stopAllMotors();
}

/**

task autonomous_Red_A()
{
//for competition - flipping caps


//goal is to turn flip CAPS and land on platform
//STEPS
//start facing backwares
//turn on flipper
//drive backwars 4 ft
//hopefully will knock ball from 1st cap
//go forward 2 feet
//turn 90 degrees left
//go back 2 feet and hit the 2nd cap
//turn 180 degrees
//start heading for platform


//place on the spots near the flags
writeDebugStreamLine("starting autonomous_A");
//turnLeftByDegrees(270);




motor[capFlip] = -126;
//goBackDistance(2050);
goBackInches(41);
//this should have grabbed ball from 1st cap
stopMotor();
motor[capFlip] = 0;
turnLeftByDegrees(70);
stopMotor();
SensorValue[leftEncoder]=0;
//turnRight(60,880);
// ---  turnLeft(60,700);
motor[capFlip] = 126;
//goBackDistance(1150);
goBackInches(23);
stopMotor();
motor[capFlip] = 0;
//this shd have flipped 2nd cap


//now start heading for the platform
//goForwardDistance(1150);
goForwardInches(23);
turnRightByDegrees(90);
goForwardDistance(2050);
turnLeftByDegrees(90);
//then go fwd short distance
motor[capFlip] = 126;
goForwardDistance(1300);
motor[capFlip] = 0;
//then turn left
turnRightByDegrees(90);
//then go fwd longer distance
//goBackDistance(2050);
goForwardDistance(41);
sleep(1000);
//shd now be on the platform




stopMotor();
}


**/


task  autonomous_Red_A()
// firing ball assuming staring as red team with the point further from flag
{
	goForwardInches(24);
turnLeftByDegrees(90);
motor[capFlip]=128;
//goBackDistance(1800);
goBackInches(36);
motor[capFlip]=0;
stopAllMotors();
}

task  autonomous_Red_B()



{


//assuming red team, further from flag, want to hit the flag
//start facing toward the flag
	// we are red tream
	// will fire ball then go after caps

	writeDebugStreamLine("starting autonomous_Red_B");


fireRockets();
//fireRockets();


//goForwardInches(46);
//goBackInches(60);
//turnLeftByDegrees(90);







//goFowardInches(40);
motor[capFlip]=128;

//goBackInches(36);


stopAllMotors();
}


task autonomous()
{
defaultMotorSpeed=126;

/**
if (SensorValue[teamSwitchPot] < 2047)
	{
		startTask(autonomous_Red_A);
		//autonomous_A has is to flip caps then go to central pad
	}
	else
	{
		startTask(autonomous_Red_B);
		//auto red b or blue b  is assuming starting nearer flags, then firing at the upper flag, then running down the lower flag, then head for platform
	}
**/

//DL 1/30/19
//CHOOSE BETWEEN 4 ROUTINES BASED ON TWO POTS
//teamSwitchPot chooses red (low) or blue (hi)
//routineSwitchPot chooses A (low) or B (hi)

if ((SensorValue[teamSwitchPot] < 2047) && (SensorValue[routineSwitchPot] < 2047))
	{
		startTask(autonomous_Red_A);
		//autonomous_A has is to flip caps then go to central pad
	}

if ((SensorValue[teamSwitchPot] < 2047) && (SensorValue[routineSwitchPot] > 2047))
	{
		startTask(autonomous_Red_B);

	}


if ((SensorValue[teamSwitchPot] > 2047) && (SensorValue[routineSwitchPot] < 2047))
	{
		startTask(autonomous_Blue_A);
		}

if ((SensorValue[teamSwitchPot] > 2047) && (SensorValue[routineSwitchPot] > 2047))
	{
		startTask(autonomous_Blue_B);

	}


writeDebugStreamLine("enc left:%d",SensorValue[leftEncoder]);

}
 //end autonomous, lol


/////////////////////////////////////////////////////////////////////////////////////////
//
//																 User Can't roll Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task user_b_bot()
{

//button 7 up: conveyor
//button 7 dn: conveyor
//button 7 up: conveyor

//set controls in forward driving mode by default

int ControllerDirection;
ControllerDirection=1;
	SensorValue[gyro1]=0;
//writeDebugStreamLine("enc left:%d",clicks);

	while(1)
	{
//		writeDebugStreamLine("pot value: %d", SensorValue[teamSwitchPot]);
		writeDebugStreamLine("enc left:%d",SensorValue[leftEncoder]);
		writeDebugStreamLine("gyro:%d",SensorValue[gyro1]);

		sleep(50);




//		Bnt8U and Bnt8U shd toggle controller direction.   You should NOT have to hold down button
		if(vexRT[Btn8U] == 1)
			{
				ControllerDirection=1;
			}

			if(vexRT[Btn8D] == 1)
			{
			   ControllerDirection=-1;
			}




if (ControllerDirection==1)
{
	//set motor speed based on controller direction

	motor[frontRight] = ControllerDirection*vexRT[Ch2];
	motor[midRight]   = ControllerDirection*vexRT[Ch2];
	motor[rearRight]  = ControllerDirection*vexRT[Ch2];

	motor[frontLeft] = ControllerDirection*vexRT[Ch3];
	motor[midLeft] = ControllerDirection*vexRT[Ch3];
	motor[rearLeft] = ControllerDirection*vexRT[Ch3];
//end set motor speed based on controllers

}


if (ControllerDirection==-1)
{
	//set motor speed based on controller direction but flip left and right

	motor[frontRight] = ControllerDirection*vexRT[Ch3];
	motor[midRight]   = ControllerDirection*vexRT[Ch3];
	motor[rearRight]  = ControllerDirection*vexRT[Ch3];

	motor[frontLeft] = ControllerDirection*vexRT[Ch2];
	motor[midLeft] = ControllerDirection*vexRT[Ch2];
	motor[rearLeft] = ControllerDirection*vexRT[Ch2];
//end set motor speed based on controllers

}

//check for cap  flipping controls
//Xmtr2
		if((vexRT[Btn5U] == 1)||(vexRT[Btn5UXmtr2] == 1))
		{
			// start the cap flipping motor
			motor[capFlip] = 126;
		}
		if((vexRT[Btn5D] == 1)||(vexRT[Btn5DXmtr2] == 1))
		{
			// stop the cap flipping motor
			motor[capFlip] = 0;
		}
		if((vexRT[Btn6U] == 1)||(vexRT[Btn6UXmtr2] == 1))
		{
		// start the cap flipping motor in reverse
			motor[capFlip] = -126;

		}
		if((vexRT[Btn6D] == 1)||(vexRT[Btn6DXmtr2] == 1))
		{
			// stop the cap flipping motor
		//	motor[capFlip] = 0;
		startFlyWheels()
		}
	  if((vexRT[Btn6D] == 0)||(vexRT[Btn6DXmtr2] == 0))
		{
			// stop the cap flipping motor
		//	motor[capFlip] = 0;
		stopFlyWheels()
		}

//check for cap flipping+converyor controls
		if((vexRT[Btn7U] == 1)||(vexRT[Btn7UXmtr2] == 1))
		{
					// start the cap flipping motor and conveyor

			motor[capFlip] = -126;
			motor[conveyor] = 126;

		}


		if((vexRT[Btn7D] == 1)||(vexRT[Btn7DXmtr2] == 1))
		{
			// stop the cap and conveyor motor
			motor[capFlip] = 0;
			motor[conveyor] = 0;
		}
		if((vexRT[Btn7L] == 1)||(vexRT[Btn7LXmtr2] == 1))
		{
		// start the cap flipping motor in reverse
			motor[capFlip] = 0;
		//	motor[conveyor] = -126;
			motor[conveyor] = -90;
		}



//check for flywheel constrol belt control.
// run leftFLyWheels in one direction
//  run rightFlyWheens in other direction
//  want to spin up then run conveyor for 1 sec
if((vexRT[Btn8R] == 1)||(vexRT[Btn8RXmtr2] == 1))
			{
		startFlyWheels();

		}

if((vexRT[Btn8L] == 1)||(vexRT[Btn8LXmtr2] == 1))
			{
		stopFlyWheels();

		}


	}
}



task usercontrol()
{
	// User control code here, inside the loop

	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.                                                                                                                    h
	// .....................................................................................

	startTask(user_b_bot);
}
