#pragma config(Sensor, in1,    teamSwitchPot,  sensorPotentiometer)
#pragma config(Motor,  port1,           frontLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rearLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           midLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           midRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rearRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          frontRight,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(bool,  port8,						teamSwitch,
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//teamSwitch = true;
void pre_auton()
{
}

//true is for blue, false is for red.
//between 708 and 4095

task autonomous()
{
}
 //end autonomous


/////////////////////////////////////////////////////////////////////////////////////////
//
//																 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task user_c_bot()
{
	while(1)
	{
		//drive
		motor[frontRight] = vexRT[Ch2];
		motor[midRight]   = vexRT[Ch2];
		motor[rearRight]  = vexRT[Ch2];

		motor[frontLeft] = vexRT[Ch3];
		motor[midLeft] = vexRT[Ch3];
		motor[rearLeft] = vexRT[Ch3];

		sleep(10);
	}
}



task usercontrol()
{
	// User control code here, inside the loop

	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.
	// .....................................................................................

	startTask(user_c_bot);
}
