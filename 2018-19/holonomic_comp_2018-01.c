#pragma config(Sensor, in1,    ClawPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    LineDetect,     sensorLineFollower)
#pragma config(Sensor, dgtl1,  shldr_enc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  mode3,          sensorDigitalIn)
#pragma config(Sensor, dgtl8,  mode2,          sensorDigitalIn)
#pragma config(Sensor, dgtl9,  mode1,          sensorDigitalIn)
#pragma config(Sensor, dgtl10, LEDY,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LEDG,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDR,           sensorLEDtoVCC)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           S1,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           S2,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           C1,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//prototypes
void initShoulder();
void initClaw();

#define MAX_MOTOR 127
#define MIN_MOTOR -127

#define DRIVE_GAIN 0.75		/* for wheel controls */
short drive_forward = 1;  // direction control +1 (forward) or -1 ( reverse )
short drive_crab = 0;  // enable/disable crab mode enable=1 disable=0


#define	CLAW_MODE_manual 0
#define	CLAW_MODE_pot 1
#define	CLAW_MODE_hold 2
#define CLAW_MODE_closing 3
#define CLAW_MODE_auto_open 4

/* Claw potentiometer wide open 3045 , closed 1876, open for stars 2600 (Feb 23 2017) */
#define CLAW_pot_open 3010
#define CLAW_pot_half_open 2600
#define CLAW_pot_closed 1900

/*  Note:  The use of globals is helpful when using the debugger */
//short lift_position;	/* potentiometer bottom 784 top 2485 Feb 17, 2017 */

//short claw_mode =	 CLAW_MODE_manual;
short claw_position;	/* actual:	potentiometer reading wide 1400, closed 2780*/
short claw_goal;		/* latched actual:	potentiometer reading when 8R is pressed */
//short claw_error;		/* difference between	 */
short claw_drive;
bool claw_hold = false;

short mode_1, mode_2, mode_3;	 /* autonomous mode variables */

short gyroValue;
short gyroGoal = 0;

/****  "shoulder" optical  encoder positions
*  assumes "Home" is 0 in the down position *** initialized at start ***
*  Up - top of travel is  130 - for maximum height when the shoulder is up
*  Limit switch - end of travel is 144
*   */
#define PARK_SHOULDER 0
#define DEPLOY_SHOULDER 50
#define MAX_SHOULDER 140
#define TOP_SHOULDER 100
#define GOAL_STEP_SIZE 1

/*   shoulder drive modes */
#define	SHOULDER_MODE_manual 0
#define SHOULDER_MODE_test 1

/* variables for closed loop shoulder control ( by position ) */
short shoulder_position = 0;
//short shoulder_mode = SHOULDER_MODE_manual;//SHOULDER_MODE_test; /* initialize in test mode - no encoder */
//short shoulder_goal = 0;
//short shoulder_error;
short shoulder_drive;

/*  Line detector - used for autonomous only to detect the lines on approach to the wall
*	white reflects high and gives low value.	grey reflects less and gives high value */
/* FIXME - confirm values */
#define LINE_white 400
#define LINE_grey	 1200
#define LINE_threshold ((LINE_white + LINE_grey)/2)
short lineValue;  /* line detector */


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

/*********************************************************************************
*  In pre-autonomous, we initialize the gyro, which requires ~ 3 seconds.
* The robot should be positioned BEFORE powering up to insure the gyro is initialized
* properly.   Note that if installing ( switching between bots ) it seems the
* cortex needs to be completely power cycled?
* Also - sample the jumpers to select the autonomous program
***************************************************************************/

void pre_auton()
{
	SensorValue[LEDG]=0; /* 0 is off, 1 is on */
	SensorValue[LEDR]=0;
	SensorValue[LEDY]=0;

	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in3] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in3] = sensorGyro;
	wait1Msec(2000);
	SensorValue[in3] = 0;	 // zero gyro
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.

	mode_1 = SensorValue[mode1];
	mode_2 = SensorValue[mode2];
	mode_3 = SensorValue[mode3];

	/* let the LED's confirm the autonomous armed or not ... red is OFF!!! */
	if (mode_3 == 0)
	{
		SensorValue[LEDR]=1;
	}
	else
	{
		SensorValue[LEDY]=1;
	}

	/* zero or initialize the shoulder encoder */
	SensorValue[shldr_enc] = 0;

	claw_position = SensorValue[ClawPot];  /* initial position ( near closed ) */
	claw_goal = claw_position + 120; /* open just a little  to deploy */

	shoulder_position = SensorValue[shldr_enc];



	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	initShoulder();
	initShoulder();
	initClaw();

	motor[FL] = 127 * DRIVE_GAIN;
	motor[FR] = 127 * DRIVE_GAIN;
	motor[BL] = 127 * DRIVE_GAIN;
	motor[BR] = 127 * DRIVE_GAIN;
	waitInMilliseconds (1000);
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;

	waitInMilliseconds (250);

	motor[FL] = 127 * DRIVE_GAIN;
	motor[FR] = -127 * DRIVE_GAIN;
	motor[BL] = 127 * DRIVE_GAIN;
	motor[BR] = -127 * DRIVE_GAIN;
	waitInMilliseconds (500);
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;
	waitInMilliseconds (250);

	motor[FL] = -127 * DRIVE_GAIN;
	motor[FR] = 127 * DRIVE_GAIN;
	motor[BL] = -127 * DRIVE_GAIN;
	motor[BR] = 127 * DRIVE_GAIN;
	waitInMilliseconds (1000);
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;
	waitInMilliseconds (250);

	motor[FL] = 127 * DRIVE_GAIN;
	motor[FR] = -127 * DRIVE_GAIN;
	motor[BL] = 127 * DRIVE_GAIN;
	motor[BR] = -127 * DRIVE_GAIN;
	waitInMilliseconds (400);
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;
	waitInMilliseconds (250);

	return;
	//////////////////////////////////////




	// .....................................................................................
	// Insert user code here.
	// .....................................................................................
	/* let the mode_1, mode_2 set the autonomous program;
	*	 1,2
	*	 1,1 start on left, pick up cube and deliver
	*	 1,0 start on right, pick up cube and deliver
	*	 0,1 start on left, pick up stars and deliver
	*	 0,0 start on right, pick up stars and deliver
	*	 let mode_3 = 0 be used to not do autonomous
	*/

	// int i;	/* loop counter */

	SensorValue[LEDG]=0; /* 0 is OFF, 1 is ON */
	SensorValue[LEDR]=0;
	SensorValue[LEDY]=0;

	/* mode_3 to bypass autonomous */
	if ( mode_3 == 0)
	{
		while(1)
		{
			waitInMilliseconds(500);
			SensorValue[LEDR]=0;
			waitInMilliseconds(500);
			SensorValue[LEDR]=1;
		}
	}
	else /* green light means GO!!!! */
	{
		SensorValue[LEDG]=1;
	}

	if (mode_3 == 1) /* works with GYRO */
	{

		/* first, deploy the claw! */
		resetTimer(T1);
		motor[C1] = -60;
		//		motor[C2] = -60;

		/* FIXME - add timeout or check if pot stops changing */
		while (SensorValue[ClawPot] < claw_goal)
		{
			waitInMilliseconds(5);
			if (getTimer(T1, seconds) > 3)
			{
				break;
			}
		}
		/* claw motor off */
		motor[C1] = 0;
		//		motor[C2] = 0;
		waitInMilliseconds(200); /* allow it to drop */

		/* now fully open the claw */
		if ( mode_2 == 1) /* going for a cube ... open wide */
		{
			claw_goal = CLAW_pot_open; // 3010
		}
		else /* pick up some stars - can't open wide! */
		{
			claw_goal = CLAW_pot_half_open; //2600
		}

		resetTimer(T1);
		motor[C1] = -60;
		//		motor[C2] = -60;
		while (SensorValue[ClawPot] < claw_goal)
		{
			waitInMilliseconds(5);
			if (getTimer(T1, seconds) > 3)
			{
				break;
			}
		}
		motor[C1] = 0;
		//		motor[C2] = 0;


		/* move forward towards the cube ( or other object ) */
		/* FIXME - add gyro control to make it go straight! */
		motor[FL] = 127;
		motor[FR] = 127;
		motor[BL] = 127;
		motor[BR] = 127;
		waitInMilliseconds (1500);
		/* step 3:  stop motor:   */
		motor[FL] = 0;
		motor[FR] = 0;
		motor[BL] = 0;
		motor[BR] = 0;

		/* close the claw - and hold - pot value is dropping as we close */
		resetTimer(T1);
		claw_position = SensorValue[ClawPot];
		motor[C1] = 60;
		//		motor[C2] = 60;
		waitInMilliseconds(1500);
		while ( (SensorValue[ClawPot] >  claw_position) /* exits if it stops closing! */
			&& (getTimer(T1, seconds) < 3) )
		{
			claw_position = SensorValue[ClawPot];
			waitInMilliseconds(100);
		}
		/* drop claw to 'hold' torque ( to avoid thermal shut-off )  */
		motor[C1] = 30;
		//		motor[C2] = 30;
		waitInMilliseconds(500);
		/* FIXME - if coming up empty, the claw will have fully closed ... open, move up, and try again! */

		/* Turn  to face the wall or away from it depending on stars or cubes */
		/* FIXME note, if on the wall getting stars, we may have to turn before deploying the outriggers
		* but if getting cubes (heavy), we may have to lift before turning */


		/* now we need to turn towards or away from the wall - mode dependent! */
		if (mode_2 == 1)  /* cube quest, turning 120 degrees from wall and lifting */
		{
			gyroGoal = 600; /* 600 = 60 degrees - face away from the wall*/
			/* lift up the cube - and deploy the outriggers at the same time */
			shoulder_position = SensorValue[shldr_enc];
			motor[S1] = 80;
			motor[S2] = 80;
			waitInMilliseconds(100);
			while ( (SensorValue[shldr_enc] <  DEPLOY_SHOULDER)
				&& (SensorValue[shldr_enc] > shoulder_position) ) /* check for 'stall' */
			{
				shoulder_position = SensorValue[shldr_enc];
				waitInMilliseconds(100);
			}
			/* hold shoulder?  move to separate process with encoder ! */
			motor[S1] = 20;
			motor[S2] = 20;
		}
		else /* going to stars ... do not deploy yet! turn 90 degrees towards the Wall */
		{
			gyroGoal = 900; /* 90 degrees */
		}

		//	turn left ( counterclockwise gyro +)	 FIXME, what about starting on the left?	Jumper option or program?
		resetTimer(T1);
		if (mode_1 != mode_2) /* cubes from right or stars from left, turn counter clockwise */
		{
			motor[FL] = -50;
			motor[BL] = -50;
			motor[FR] = 50;
			motor[BR] = 50;
		}
		else	/* cubes from right or starts from left, turn clockwise */
		{
			motor[FL] = 50;
			motor[BL] = 50;
			motor[FR] = -50;
			motor[BR] = -50;
		}

		/* turn either way until reaching goal - absolute value */
		gyroValue = SensorValue[in3];

		while(abs(gyroValue) < gyroGoal)
		{
			gyroValue = SensorValue[in3];
			wait1Msec(1);
			if (getTimer(T1, seconds) > 2)
			{
				break;
			}
		}
		/* apply brake */
		if (mode_1 != mode_2)
		{
			motor[FL] = 5;
			motor[BL] = 5;
			motor[FR] = -5;
			motor[BR] = -5;
		}
		else
		{
			motor[FL] = -5;
			motor[BL] = -5;
			motor[FR] = 5;
			motor[BR] = 5;
		}
		wait1Msec(50);

#if 0   /* not tested yet ... */
		/* if stars, move forward, then turn 180 degrees and deploy outrigger */
		if (mode_2 == 0)
		{
			/* move forward */
			motor[FL] = 50;
			motor[BL] = 50;
			motor[FR] = 50;
			motor[BR] = 50;
			wait1Msec(200);
			motor[FL] = 0;
			motor[BL] = 0;
			motor[FR] = 0;
			motor[BR] = 0;

			/* now we need to turn towards or away from the wall - mode dependent! */

			gyroGoal = 2700; /* 180 degrees - face  to the wall*/
			shoulder_position = SensorValue[shldr_enc];
			motor[S1] = 75;
			motor[S2] = 75;
			waitInMilliseconds(1000);

			while ( (SensorValue[shldr_enc] <  DEPLOY_SHOULDER)
				&& (SensorValue[shldr_enc] > shoulder_position) ) /* check for 'stall' */
			{
				shoulder_position = SensorValue[shldr_enc];
				waitInMilliseconds(100);

			}
			motor[S1] = 20;
			motor[S2] = 20;
		}  /* `end stars move from wall */
		else
		{
			gyroGoal = 2700; /* 180 degrees - face  to the wall*/
		}

		//	turn left ( counterclockwise gyro +)	 FIXME, what about starting on the left?	Jumper option or program?
		if (mode_1 != mode_2) /* cubes from right or stars from left, turn counter clockwise */
		{
			motor[FL] = -50;
			motor[BL] = -50;
			motor[FR] = 50;
			motor[BR] = 50;
		}
		else	/* cubes from right or starts from left, turn clockwise */
		{
			motor[FL] = 50;
			motor[BL] = 50;
			motor[FR] = -50;
			motor[BR] = -50;
		}

		/* turn either way until reaching goal - absolute value */
		resetTimer(T1);
		while(abs(gyroValue) < gyroGoal)
		{
			gyroValue = SensorValue[in4];
			wait1Msec(1);
			if (getTimer(T1, seconds) > 2)
			{
				break;
			}
		}
		/* apply brake */
		if (mode_1 != mode_2)
		{
			motor[FL] = 5;
			motor[BL] = 5;
			motor[FR] = -5;
			motor[BR] = -5;
		}
		else
		{
			motor[FL] = -5;
			motor[BL] = -5;
			motor[FR] = 5;
			motor[BR] = 5;
		}
		wait1Msec(50);

#endif

		/*  next - go all the way to the fence ... backwards */
		/* FIXME - add gyro control to make it go straight! */
		motor[FL] = -70;
		motor[BL] = -70;
		motor[FR] = -70;
		motor[BR] = -70;

		wait1Msec(3000);

		/*  then launch the payload and open claw at top */
		shoulder_position = SensorValue[shldr_enc];
		motor[S1] = 120;
		motor[S2] = 120;
		waitInMilliseconds(100);
		while ( (SensorValue[shldr_enc] <  MAX_SHOULDER)
			&& (SensorValue[shldr_enc] > shoulder_position) ) /* check for 'stall' */
		{
			shoulder_position = SensorValue[shldr_enc];
			waitInMilliseconds(100);
			if	(SensorValue[shldr_enc] >  TOP_SHOULDER)
			{
				motor[C1] = -127;
				//				motor[C2] = -127;

			}
		}
		/* then .. call it quits!!! */

		motor[C1] = 0;
		//		motor[C2] = 0;
		motor[S1] = 0;
		motor[S2] = 0;


	}
	else  // mode_3 - old manual mode
	{
		//#if 0  /* FIXME  old autonomous - use this with 'mode_3'? */
		waitInMilliseconds (500);
		motor[S1] = 75;
		motor[S2] = 75;
		waitInMilliseconds (1000);
		motor[S1] = 0;
		motor[S2] = 0;
		waitInMilliseconds (1000);
		/* step 4:  back off ( shake off star? ) */
		/* all motors off  */
		/*  FIXME - we have an encoder now ... do something with the wrist and shoulder !!!! */
		motor[FL] = -127;
		motor[FR] = -127;
		motor[BL] = -127;
		motor[BR] = -127;
		waitInMilliseconds (1500);
	}

	allMotorsOff();
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void clawControl()
{
	/***********************************************
	*****************			 claw			**************
	* Use button 6D/U to close/open the claw
	*
	*********************************************/

	if (vexRT[Btn6D] == 1)	 /* manual drive close 6D */
	{
		claw_drive = -90;
		claw_hold = false;
	}
	else if (vexRT[Btn6U] == 1)	 /* manual drive open 6U */
	{
		claw_drive = 90;
		claw_hold = false;
	}
	else if (vexRT[Btn8D] == 1)
	{
		claw_hold = true;
		claw_drive = -60;
	}
	else //all controls released
	{
		if(claw_hold)
		{
			claw_drive = -30;
		}
		else
		{
			claw_drive = 0;
		}
	}

	/* now set the motor drive */
	motor[C1] = claw_drive;

}

void shoulderControl()
{
	/*************************************************************************
	*****************        SHOULDER control         ***********************
	* normal 'motor control' Btn5U/D controls motor drive up/down
	*************************************************************************/
	shoulder_position = SensorValue[shldr_enc];
	//writeDebugStreamLine("shoulder_position: %d", shoulder_position);
	SensorValue[LEDY]=1;
	///
	//button 5U to raise lift until it reaches position 100
	if((vexRT[Btn5U] == 1)&&(shoulder_position < 100))
	{
		shoulder_drive = 50;
		writeDebugStreamLine("pos: %d, driv: %d", shoulder_position,shoulder_drive);
	}
	///
	//button 5D to lower lift
	else if(vexRT[Btn5D] == 1)
	{
		//operate at half power between top and mid position
		if(shoulder_position > 40)
		{
			shoulder_drive = -50;
			writeDebugStreamLine("pos: %d, driv: %d", shoulder_position,shoulder_drive);
		}
		//operate at 10% below half
		else if ((shoulder_position < 40)&&(shoulder_position > 5))
		{
			shoulder_drive = -25;
			writeDebugStreamLine("pos: %d, driv: %d", shoulder_position,shoulder_drive);
		}
		//minimum power near lowest position
		else if (shoulder_position < 1)
		{
			shoulder_drive = -5;
			writeDebugStreamLine("pos: %d, driv: %d", shoulder_position,shoulder_drive);
		}
	}
	else
	{
		shoulder_drive = 0;
	}

	motor[S1] = shoulder_drive ;
	motor[S2] = shoulder_drive ;


}



void initShoulder()
{
	writeDebugStreamLine("initShoulder");
	bool done = false;
	int current_position = 0;
	int previous_position = 0;
	int diff;
	while(!done)
	{
		previous_position = SensorValue[shldr_enc];

		shoulder_drive = -15;
		motor[S1] = shoulder_drive ;
		motor[S2] = shoulder_drive ;
		sleep(500);
		shoulder_drive = 0;
		motor[S1] = shoulder_drive ;
		motor[S2] = shoulder_drive ;

		current_position = SensorValue[shldr_enc];
		diff = abs(current_position) - abs(previous_position);
		writeDebugStreamLine("comparing: %d -- %d [%d]", previous_position,current_position,diff);
		if(diff <= 1)
		{
			done = true;
			SensorValue[shldr_enc] = 0;
		}
	}

}

void initClaw()
{
	writeDebugStreamLine("initClaw");
	motor[C1] = -60; //close
	sleep(750);

	motor[C1] = 60;
	sleep(750);
	motor[C1] = 0;
}

task user_a_bot()
{
	short x1,x2,m_drive;
	short LED_toggle = 0;   /* used for 'heart beat ' */

	SensorValue[LEDG]=1;  /* 0 is OFF, 1 is ON */
	SensorValue[LEDR]=0;
	SensorValue[LEDY]=0;

	while(1)
	{
		/* heartbeat ... it's alive!!!! */
		if (LED_toggle++ == 10)
		{
			SensorValue[LEDG]=1;
		}
		else if (LED_toggle == 20)
		{
			SensorValue[LEDG]=0;
			LED_toggle = 0;
		}

		/**********************************************************************
		*****               holomonic wheels       ***************************
		*   are controlled here with the joy-sticks "tractor mode"
		*  Use buttons 7U ( forward ) and 7D ( backwards ) to reverse the drive
		*  Include 'lateral' drive override using ch 1 or ch 4
		*  Vex joy stick controller output -127 to +127, which is matched to the
		*  motor commands.   ( However, note that some references online
		*  suggest that the 3-wire motor controllers MAY max out at +/- 80
		*********************************************************************/
		/* allow left/right on 1 or 4 if over some threshold */
		x1 = abs(vexRT[Ch1]);
		x2 = abs(vexRT[Ch4]);
		if (x1>x2)
		{
			m_drive = 1*vexRT[Ch1];
		}
		else
		{
			m_drive = 1* vexRT[Ch4];	 /* 1&4 controls are backwards */
		}

		/* Note:  The drivers complain that they are triggering the H-drive
		*  accidentally because they rotate instead of going back and forth
		* in tank drive, so we moved the threshold all the way to 125 to avoid
		* unintended triggers */
		if((m_drive > 100) || (m_drive < -100))
		{
			motor[FL] = m_drive * DRIVE_GAIN;
			motor[FR] = -1*m_drive * DRIVE_GAIN;
			motor[BL] = -1*m_drive * DRIVE_GAIN;
			motor[BR] = m_drive * DRIVE_GAIN;
		}
		else if (drive_forward == 1)
		{
			motor[FL] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
			motor[FR] = vexRT[Ch2] * DRIVE_GAIN; // / 1;
			motor[BL] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
			motor[BR] = vexRT[Ch2] * DRIVE_GAIN; // / 1;
		}
		else if (drive_forward == -1)
		{
			motor[FL] = vexRT[Ch2] * DRIVE_GAIN; // / 1;
			motor[FR] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
			motor[BL] = vexRT[Ch2] * DRIVE_GAIN; // / 1;
			motor[BR] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
		}


		/*  FIXME:  add other drive modes depending on the driver preference */
		/*
		if (vexRT[Btn7U] == 1)
		{
			drive_forward = 1;
		}
		else if (vexRT[Btn7D] == 1)
		{
			drive_forward = -1;
		}
    */
		//	motor[S1] = vexRT[Btn5U] / Btn5D;
		//	motor[S2] = vexRT[Btn5U] / Btn5D;
		//	motor[W] = vexRT[Btn6U] / Btn6D;

		/*   define potentiometer variables for position control here */
		lineValue = SensorValue[LineDetect];
		//shoulder_position = SensorValue[shldr_enc];  // shoulder encoder
		//claw_position = SensorValue[ClawPot];	 // claw potentiometer goes 0 to 4095

		//crab mode
		if (vexRT[Btn7R] == 1)
		{
			motor[FL] = -127 * -DRIVE_GAIN; // / 1;
			motor[BR] = -127 * -DRIVE_GAIN; // / 1;
		}
		if (vexRT[Btn7L] == 1)
		{
			motor[FL] = 127 * -DRIVE_GAIN; // / 1;
			motor[BR] = 127 * -DRIVE_GAIN; // / 1;
		}
		if (vexRT[Btn7D] == 1)
		{
			motor[FR] = 127 * -DRIVE_GAIN; // / 1;
			motor[BL] = 127 * -DRIVE_GAIN; // / 1;
		}
		if (vexRT[Btn7U] == 1)
		{
			motor[FR] = -127 * -DRIVE_GAIN; // / 1;
			motor[BL] = -127 * -DRIVE_GAIN; // / 1;
		}


		/*****************        SHOULDER control         ***********************/
		shoulderControl();


		/*****************			 claw			**************/
		clawControl();


		wait1Msec(20);

	}	 // end while(1)
}	 // end task

task usercontrol()
{
	// User control code here, inside the loop

	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.
	// .....................................................................................


	initShoulder();
	initShoulder();
	initClaw();

	startTask(user_a_bot);
}
