#pragma config(Sensor, dgtl1,  shldr_enc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  wrist_enc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  shldr_limit,    sensorTouch)
#pragma config(Sensor, dgtl11, LEDG,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDR,           sensorLEDtoVCC)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           S1,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           S2,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           W,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BL,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/* wrist encoder positions
*  assumes "Home" is 0 in the up position
*  Open or down for picking up is 102
*  Fully extended is 124 - for maximum height when the shoulder is up
*  Furthest down is 218 ( end of travel - furthest down
*   */
#define MAX_WRIST 218
#define PARK_WRIST 0
#define PICK_WRIST 102
#define REACH_WRIST 124
#define DUMP_WRIST 69


/* shoulder encoder positions
*  assumes "Home" is 0 in the down position
*  Up - top of travel is  130 - for maximum height when the shoulder is up
*  Limit switch - end of travel is 144
*   */
#define PARK_SHOULDER 0
#define MAX_SHOULDER 140
#define TOP_SHOULDER 130

#define WRIST_SLOPE(x)		(((REACH_WRIST - PICK_WRIST)*x)/(TOP_SHOULDER - PARK_SHOULDER))


#define GOAL_STEP_SIZE 2

/*   shoulder drive modes */
#define	SHOULDER_MODE_manual 0
#define SHOULDER_MODE_test 1

/*   wrist drive modes */
#define	WRIST_MODE_manual 0
#define	WRIST_MODE_slave 1
//#define	WRIST_MODE_lift 2
//#define	WRIST_MODE_slam 3
//#define WRIST_MODE_recover 4
#define WRIST_MODE_test 5



short wrist_position = 0;
short shoulder_position = 0;

	short wrist_mode =  WRIST_MODE_test; //WRIST_MODE_manual;		/* initialize in test mode - no encoder */
	short wrist_goal = PARK_WRIST;
	short wrist_error;
	short wrist_drive;

  short shoulder_mode = SHOULDER_MODE_manual;//SHOULDER_MODE_test; /* initialize in test mode - no encoder */
	short shoulder_goal = 0;
	short shoulder_error;
	short shoulder_drive;


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

/* In the 'pre-automonous' mode, we need to make sure that
* the shovel is not deployed ( by the rubber bands )
* So use the encoder to control the wrist motor
*****  Assumes that the program begins with the shoulder
*   and wrist in the 'park' position to initialize both
*   encoders at 0
*/
task hold_wrist()
{
	short wrist_drive;

	while ( true )
	{
		wrist_position = SensorValue[wrist_enc];  // wrist encoder

		if ( wrist_position > 4 )
		{
			/* a drive of 25 seems to hold the wrist up at park - CONFIRM!!! */
			wrist_drive = wrist_position * 6;
			motor[W] = wrist_drive;
		}
		else
		{
			/* low power hold mode ... may oscillate */
			wrist_drive = wrist_position * 3;
			motor[W] = wrist_drive;
		}

		waitInMilliseconds(20); // delay?

	}
}

void pre_auton()
{

	// hold the wrist in up position

	SensorValue[wrist_enc] = 0;  // wrist encoder
	SensorValue[shldr_enc] = 0;
	wrist_position = SensorValue[wrist_enc];
	shoulder_position = SensorValue[shldr_enc];
	startTask(hold_wrist);



	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

	stopTask(hold_wrist);

	motor[FL] = 127;
	motor[FR] = 127;
	motor[BL] = 127;
	motor[BR] = 127;
	waitInMilliseconds (3000);
	/* step 3:  stop motor:  lift up to knock off a star */
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;
	waitInMilliseconds (500);
	motor[S1] = 75;
	motor[S2] = 75;
	waitInMilliseconds (1000);
	motor[S1] = 0;
	motor[S2] = 0;
	waitInMilliseconds (1000);
	/* step 4:  back off ( shake off star? ) */
	/* all motors off  */
	/*  FIXME - we have an encoder now ... do something with the wrist and shoulder !!!! */
	motor[FL] = -127;
	motor[FR] = -127;
	motor[BL] = -127;
	motor[BR] = -127;
	waitInMilliseconds (1500);
	allMotorsOff();
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


#define MAX_MOTOR 127
#define MIN_MOTOR -127



#define DRIVE_GAIN 0.75

task user_a_bot()
{
	//	int wrist_up = 0;  // keep track of last action up?
	//  int elbow_up = 0;

//	short wrist_mode =  WRIST_MODE_test; //WRIST_MODE_manual;		/* initialize in test mode - no encoder */
//	short wrist_goal = PARK_WRIST;
//	short wrist_error;
//	short wrist_drive;

//	short shoulder_mode = SHOULDER_MODE_manual;//SHOULDER_MODE_test; /* initialize in test mode - no encoder */
//	short shoulder_goal = 0;
//	short shoulder_error;
//	short shoulder_drive;
	short shoulder_limit;
	short limit_count = 0;
	SensorValue[LEDG]=false;
	SensorValue[LEDR]=false;

	while(1 == 1)
	{
		/**********************************************************************
		*****               holomonic wheels       ***************************
		*   are controlled here with the joy-sticks "tractor mode"
		*********************************************************************/

		motor[FL] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
		motor[FR] = vexRT[Ch2] * DRIVE_GAIN; // / 1;
		motor[BL] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
		motor[BR] = vexRT[Ch2] * DRIVE_GAIN; // / 1;


		/*  ToDo:  add other drive modes depending on the driver preference */



		//	motor[S1] = vexRT[Btn5U] / Btn5D;
		//	motor[S2] = vexRT[Btn5U] / Btn5D;
		//	motor[W] = vexRT[Btn6U] / Btn6D;

		/*   define potentiometer variables for position control here */
		wrist_position = SensorValue[wrist_enc];  // wrist encoder
		shoulder_position = SensorValue[shldr_enc];  // shoulder encoder
		shoulder_limit = SensorValue[shldr_limit];   // touch sensor or limit switch on shoulder top

		/*************************************************************************
		*****************        SHOULDER control         ***********************
		* Test Mode:   normal 'motor control' Btn5U/D controls motor drive up/down
		*        set with button 8L
		* Manual Mode:  position control:  Btn5U/D controls motor position up/down
		*        set with button 8U or 8D
		*************************************************************************/
		//		if ((vexRT[Btn8U] == 1) && (vexRT[Btn8D] == 1) && (vexRT[Btn8R] == 1) )
		//	  {
		//		 	SensorValue[wrist_enc] = 0;  // wrist encoder
		//	    SensorValue[shldr_enc] = 0;
		//  	}

		//		if((vexRT[Btn8U] == 1) || (vexRT[Btn8D] == 1))
		//		{
		shoulder_mode =  SHOULDER_MODE_manual;  /* position drive using encoder for 'hold' */
		//			shoulder_goal = shoulder_position;
		//		}
#if 0
		else if(vexRT[Btn8L] == 1)
		{
			shoulder_mode =  SHOULDER_MODE_test;   /* test motors - no encoder */
		}

		/*   now drive the wrist motor depending on the mode */
		if (shoulder_mode ==  SHOULDER_MODE_test)	/* drive motors directly up/down - for testing!!! */
		{
			SensorValue[LEDR]=false;
			if((vexRT[Btn5U]) && (shoulder_limit == 0))     //If button 6U is pressed... instruct the wrist UP higher
			{
				motor[S1] = 127 ;
				motor[S2] = 127 ;    //...raise the arm.
			}
			else if(vexRT[Btn5D] == 1)  	//Else, if button 6D is pressed... instruct the wrist DOWN lower
			{
				motor[S1] = -127 ;
				motor[S2] = -127 ;    // ... lower the arm
			}
			else
			{
				motor[S1] = 0 ;
				motor[S2] = 0 ;    // ... lower the arm
			}
		}  // END SHOULDER_MODE_test - drive motors directly
		else if (shoulder_mode ==  SHOULDER_MODE_manual)  /* control the shoulder by position ( encoder ) */
#endif
		if (shoulder_mode ==  SHOULDER_MODE_manual)  /* control the shoulder by position ( encoder ) */
		{
			SensorValue[LEDR]=true;
			/*  Step 1:  check to see if the goal needs to be updated */
			if(vexRT[Btn5U] == 1)     // == 1)       	//If button 5U is pressed... instruct the shoulder UP higher
			{
				if(shoulder_goal < (shoulder_position + GOAL_STEP_SIZE))
				{
					shoulder_goal = (shoulder_position + GOAL_STEP_SIZE);
					if (shoulder_goal > MAX_SHOULDER)
					{
						shoulder_goal = MAX_SHOULDER;
					}
				}
				else if(shoulder_goal < (MAX_SHOULDER-GOAL_STEP_SIZE))	/* limit check */
				{
					shoulder_goal += GOAL_STEP_SIZE;
				}
			}
			else if(vexRT[Btn5D] == 1)  	//Else, if button 5D is pressed... instruct the shoulder DOWN lower
			{
				if(shoulder_goal > (shoulder_position - GOAL_STEP_SIZE))
				{
					shoulder_goal = (shoulder_position - GOAL_STEP_SIZE);
					if (shoulder_goal < 0)
					{
						shoulder_goal = 0;
					}
				}
				else if(shoulder_goal > GOAL_STEP_SIZE)  /* limit check */
				{
					shoulder_goal -= GOAL_STEP_SIZE;
				}
			}

			/*  Step 2:  Apply the drive based on the goal and error */
			//completely flat=1982 when down
			//up all the way=3584
			//flat up all the way=0

			shoulder_error = shoulder_goal - shoulder_position ;
			shoulder_drive =  shoulder_error * 3;
			if (shoulder_drive > MAX_MOTOR )   /* limit check */
			{
				shoulder_drive = MAX_MOTOR;
			}
			else if (shoulder_drive < MIN_MOTOR ) /* limit check */
			{
				shoulder_drive = MIN_MOTOR;
			}

			/* limit switch  check! */
			if ((shoulder_limit == 1) && (shoulder_drive > 0))
			{
				shoulder_drive = 0;
			}
			/* drive the motor according to the error signal */
			motor[S1] = shoulder_drive ;
			motor[S2] = shoulder_drive ;
		}  // end SHOULDER_MODE_manual  ( position drive with encoder )
		//		else  // shoulder_mode undefined !!!!
		//		{
		//			motor[S1] = 0 ;
		//			motor[S2] = 0 ;
		//			shoulder_mode =  SHOULDER_MODE_test;
		// ToDo  set error mode
		//		}

		/* if we are somehow at the limit - reset the encoder */
		if (shoulder_limit == 1)
		{
			limit_count += 1;
			if (limit_count >= 10)
			{
				SensorValue[shldr_enc] = MAX_SHOULDER;
			}
	  }
	  else
	  {
	  	limit_count = 0;
	  }

		/*************************************************************************
		***************************      wrist control    ************************
		*  Test Mode:   normal 'motor control' Btn6U/D controls motor drive up/down
		*        set with button 8R
		*  Manual Mode:  position control:  Btn6U/D controls motor position up/down
		*        set with button 8U
		*  Slave Mode:  position control: shoulder position controls wrist goal
		*        set with button 8D
		*************************************************************************/
		if(vexRT[Btn8U] == 1)
		{
			wrist_mode =  WRIST_MODE_manual;
			wrist_goal = wrist_position;
		}
		else if(vexRT[Btn8D] == 1)
		{
			wrist_mode =  WRIST_MODE_slave;
		}
		else if(vexRT[Btn8R] == 1)
		{
			wrist_mode =  WRIST_MODE_test;
		}


		/*   now drive the wrist motor depending on the mode */
		if (wrist_mode ==  WRIST_MODE_test)	/* drive motors directly up/down - for testing!!! */
		{
			SensorValue[LEDG]=false;
			if(vexRT[Btn6U] == 1)     //If button 6U is pressed... instruct the wrist UP higher
			{
				motor[W] = 110;    	//...raise the hand.
			}
			else if(vexRT[Btn6D] == 1)  	//Else, if button 6D is pressed... instruct the wrist DOWN lower
			{
				motor[W] = -110;   // ... lower the hand
			}
			else
			{
				motor[W] = 0;   // ... off
			}

		}  // end WRIST_MODE_test
		else  /* drive motors based on encoder  */
		{
			if (wrist_mode ==  WRIST_MODE_slave)
			{
				SensorValue[LEDG]=true;

				//				wrist_goal = PICK_WRIST + WRIST_SLOPE(shoulder_position);
				wrist_goal = PICK_WRIST + shoulder_position/6;
				/* the wrist_position encoder will go from 0 to 124 over 220 degrees of travel
				* When picking up, it starts at 102, and as the shoulder goes up to top
				*
				* the motor control goes from -127 to + 128
				* generate an error signal between actual position and 'goal' to control the wrist motor */
				if ((vexRT[Btn6U] == 1) || (vexRT[Btn6D] == 1))
				{
					wrist_mode =  WRIST_MODE_manual;
					wrist_goal = wrist_position;
				}
			}  // end WRIST_MODE_slave
			else if (wrist_mode ==  WRIST_MODE_manual)
			{
				SensorValue[LEDG]= !SensorValue[LEDG] ;
				if (vexRT[Btn6D] == 1)
				{
					//wrist_mode =  WRIST_MODE_manual;
					//wrist_goal = PARK_WRIST;
					if (wrist_goal < (wrist_position + GOAL_STEP_SIZE))
					{
						wrist_goal = (wrist_position + GOAL_STEP_SIZE);
						if (wrist_goal > MAX_WRIST)
						{
							wrist_goal = MAX_WRIST;
						}
					}
					else if (wrist_goal < (MAX_WRIST-GOAL_STEP_SIZE))   /* limit check */
					{
						wrist_goal += GOAL_STEP_SIZE;
					}
				}
				else if (vexRT[Btn6U] == 1)
				{
					if (wrist_goal > (wrist_position - GOAL_STEP_SIZE))
					{
						wrist_goal = (wrist_position - GOAL_STEP_SIZE);
						if (wrist_goal < 0)
						{
							wrist_goal = 0;
						}
					}
					else if (wrist_goal > GOAL_STEP_SIZE)   /* limit check */
					{
						wrist_goal -= GOAL_STEP_SIZE;
					}

				}
			}  // end WRIST_MODE_manual
//			else  // ERROR - no valid mode is defined!!!
//			{
//				wrist_goal = wrist_position;  // disable wrist
				// ToDo - set error mode
//				if ((vexRT[Btn6U] == 1) || (vexRT[Btn6D] == 1))
//				{
//					wrist_mode =  WRIST_MODE_manual;
//				}
//			}

			/****** If under position control, now use the
			*  position goal as determined above depending
			*  on the mode, and now apply the drive *******/
			wrist_error = wrist_goal - wrist_position ;
			wrist_drive =  wrist_error * 10;
			if (wrist_drive > MAX_MOTOR )   /* limit check */
			{
				wrist_drive = MAX_MOTOR;
			}
			else if (wrist_drive < MIN_MOTOR )   /* limit check */
			{
				wrist_drive = MIN_MOTOR;
			}
			/* drive the motor according to the error signal */
			motor[W] = -wrist_drive ;
		} // end driving wrist based on position-encoder

		/**************   end of wrist control *********************/


		waitInMilliseconds(10); // delay?

	}  // end while(1)
}  // end task_main()


task usercontrol()
{
	// User control code here, inside the loop

	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.
	// .....................................................................................

	stopTask(hold_wrist);
	startTask(user_a_bot);
}
