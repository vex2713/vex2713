#pragma config(Sensor, in1,    claw_pot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  shldr_enc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl10, LEDY,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LEDG,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDR,           sensorLEDtoVCC)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           S1,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           S2,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           C1,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           C2,            tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//potentiometer: small numbers closed lage numbers opened
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/* wrist encoder positions
*  assumes "Home" is 0 in the up position
*  Open or down for picking up is 102
*  Fully extended is 124 - for maximum height when the shoulder is up
*  Furthest down is 218 ( end of travel - furthest down
*   */
#define MAX_WRIST 218
#define PARK_WRIST 0
#define PICK_WRIST 102
#define REACH_WRIST 124
#define DUMP_WRIST 69

#define	CLAW_MODE_manual 0
#define	CLAW_MODE_pot 1
#define	CLAW_MODE_hold 2
#define MAXIMUM_CLAWPOT 3074
#define MINIMUM_CLAWPOT 1829

short lineValue;
short liftValue;	 /* lift encoder bottom to top ~ 110 */
short lift_position;	/* potentiometer bottom 784 top 2485 Feb 17, 2017 */
short claw_mode =	 CLAW_MODE_manual;
short claw_position;	/* actual:	potentiometer reading wide 1400, closed 2780*/
short claw_goal;		/* latched actual:	potentiometer reading when 8R is pressed */
short claw_error;		/* difference between	 */
short claw_drive;



/* shoulder encoder positions
*  assumes "Home" is 0 in the down position
*  Up - top of travel is  130 - for maximum height when the shoulder is up
*  Limit switch - end of travel is 144
*   */
#define PARK_SHOULDER 0
#define MAX_SHOULDER 140
#define TOP_SHOULDER 130

#define WRIST_SLOPE(x)		(((REACH_WRIST - PICK_WRIST)*x)/(TOP_SHOULDER - PARK_SHOULDER))


#define GOAL_STEP_SIZE 1

/*   shoulder drive modes */
#define	SHOULDER_MODE_manual 0
#define SHOULDER_MODE_test 1


short drive_forward = 1;  // direction control +1 (forward) or -1 ( reverse )

short shoulder_position = 0;


short shoulder_mode = SHOULDER_MODE_manual;//SHOULDER_MODE_test; /* initialize in test mode - no encoder */
short shoulder_goal = 0;
short shoulder_error;
short shoulder_drive;


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

/* In the 'pre-automonous' mode, we need to make sure that
* the shovel is not deployed ( by the rubber bands )
* So use the encoder to control the wrist motor
*****  Assumes that the program begins with the shoulder
*   and wrist in the 'park' position to initialize both
*   encoders at 0
*/
task hold_wrist()
{
	short wrist_drive;
#if 0
	while ( true )
	{
		wrist_position = SensorValue[wrist_enc];  // wrist encoder

		if ( wrist_position > 4 )
		{
			/* a drive of 25 seems to hold the wrist up at park - CONFIRM!!! */
			wrist_drive = wrist_position * 6;
			motor[C1] = wrist_drive;
				motor[C2] = wrist_drive;
		}
		else
		{
			/* low power hold mode ... may oscillate */
			wrist_drive = wrist_position * 3;
					motor[C1] = wrist_drive;
				motor[C2] = wrist_drive;
		}

		waitInMilliseconds(20); // delay?

	}
#endif
}

void pre_auton()
{

	// hold the wrist in up position

//	SensorValue[wrist_enc] = 0;  // wrist encoder
	SensorValue[shldr_enc] = 0;
	shoulder_position = SensorValue[shldr_enc];
	startTask(hold_wrist);



	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

	stopTask(hold_wrist);

	motor[FL] = 127;
	motor[FR] = 127;
	motor[BL] = 127;
	motor[BR] = 127;
	waitInMilliseconds (3000);
	/* step 3:  stop motor:  lift up to knock off a star */
	motor[FL] = 0;
	motor[FR] = 0;
	motor[BL] = 0;
	motor[BR] = 0;
	waitInMilliseconds (500);
	motor[S1] = 75;
	motor[S2] = 75;
	waitInMilliseconds (1000);
	motor[S1] = 0;
	motor[S2] = 0;
	waitInMilliseconds (1000);
	/* step 4:  back off ( shake off star? ) */
	/* all motors off  */
	/*  FIXME - we have an encoder now ... do something with the wrist and shoulder !!!! */
	motor[FL] = -127;
	motor[FR] = -127;
	motor[BL] = -127;
	motor[BR] = -127;
	waitInMilliseconds (1500);
	allMotorsOff();
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


#define MAX_MOTOR 127
#define MIN_MOTOR -127



#define DRIVE_GAIN 0.75

task user_a_bot()
{
	//	int wrist_up = 0;  // keep track of last action up?
	//  int elbow_up = 0;

	//	short wrist_mode =  WRIST_MODE_test; //WRIST_MODE_manual;		/* initialize in test mode - no encoder */
	//	short wrist_goal = PARK_WRIST;
	//	short wrist_error;
	//	short wrist_drive;

	//	short shoulder_mode = SHOULDER_MODE_manual;//SHOULDER_MODE_test; /* initialize in test mode - no encoder */
	//	short shoulder_goal = 0;
	//	short shoulder_error;
	//	short shoulder_drive;
	short shoulder_limit;
	short limit_count = 0;
	SensorValue[LEDG]=false;
	SensorValue[LEDR]=false;

	while(1 == 1)
	{
		/**********************************************************************
		*****               holomonic wheels       ***************************
		*   are controlled here with the joy-sticks "tractor mode"
		*  Use buttons 7U ( forward ) and 7D ( backwards ) to reverse the drive
		*********************************************************************/
		if (drive_forward == 1)
		{
			motor[FL] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
			motor[FR] = vexRT[Ch2] * DRIVE_GAIN; // / 1;
			motor[BL] = vexRT[Ch3] * DRIVE_GAIN; // / 1;
			motor[BR] = vexRT[Ch2] * DRIVE_GAIN; // / 1;
		}
		else if (drive_forward == -1)
		{
			motor[FL] = vexRT[Ch2] * -DRIVE_GAIN; // / 1;
			motor[FR] = vexRT[Ch3] * -DRIVE_GAIN; // / 1;
			motor[BL] = vexRT[Ch2] * -DRIVE_GAIN; // / 1;
			motor[BR] = vexRT[Ch3] * -DRIVE_GAIN; // / 1;


		}


		/*  ToDo:  add other drive modes depending on the driver preference */

		if (vexRT[Btn7U] == 1)
		{
			drive_forward = 1;
		}
		else if (vexRT[Btn7D] == 1)
		{
			drive_forward = -1;
		}

		//	motor[S1] = vexRT[Btn5U] / Btn5D;
		//	motor[S2] = vexRT[Btn5U] / Btn5D;
		//	motor[W] = vexRT[Btn6U] / Btn6D;

		/*   define potentiometer variables for position control here */
//		wrist_position = SensorValue[wrist_enc];  // wrist encoder
		shoulder_position = SensorValue[shldr_enc];  // shoulder encoder
//		shoulder_limit = SensorValue[shldr_limit];   // touch sensor or limit switch on shoulder top

		/*************************************************************************
		*****************        SHOULDER control         ***********************
		* Test Mode:   normal 'motor control' Btn5U/D controls motor drive up/down
		*        set with button 8L
		* Manual Mode:  position control:  Btn5U/D controls motor position up/down
		*        set with button 8U or 8D
		*************************************************************************/
		//		if ((vexRT[Btn8U] == 1) && (vexRT[Btn8D] == 1) && (vexRT[Btn8R] == 1) )
		//	  {
		//		 	SensorValue[wrist_enc] = 0;  // wrist encoder
		//	    SensorValue[shldr_enc] = 0;
		//  	}

		//		if((vexRT[Btn8U] == 1) || (vexRT[Btn8D] == 1))
		//		{
		shoulder_mode =  SHOULDER_MODE_manual;  /* position drive using encoder for 'hold' */
		//			shoulder_goal = shoulder_position;
		//		}
#if 0
		else if(vexRT[Btn8L] == 1)
		{
			shoulder_mode =  SHOULDER_MODE_test;   /* test motors - no encoder */
		}

		/*   now drive the wrist motor depending on the mode */
		if (shoulder_mode ==  SHOULDER_MODE_test)	/* drive motors directly up/down - for testing!!! */
		{
			SensorValue[LEDR]=false;
			if((vexRT[Btn5U]) && (shoulder_limit == 0))     //If button 6U is pressed... instruct the wrist UP higher
			{
				motor[S1] = 127 ;
				motor[S2] = 127 ;    //...raise the arm.
			}
			else if(vexRT[Btn5D] == 1)  	//Else, if button 6D is pressed... instruct the wrist DOWN lower
			{
				motor[S1] = -127 ;
				motor[S2] = -127 ;    // ... lower the arm
			}
			else
			{
				motor[S1] = 0 ;
				motor[S2] = 0 ;    // ... lower the arm
			}
		}  // END SHOULDER_MODE_test - drive motors directly
		else if (shoulder_mode ==  SHOULDER_MODE_manual)  /* control the shoulder by position ( encoder ) */
#endif
		if (shoulder_mode ==  SHOULDER_MODE_manual)  /* control the shoulder by position ( encoder ) */
		{
			SensorValue[LEDR]=true;
			/*  Step 1:  check to see if the goal needs to be updated */
			if(vexRT[Btn5U] == 1)     // == 1)       	//If button 5U is pressed... instruct the shoulder UP higher
			{
				if(shoulder_goal < (shoulder_position + GOAL_STEP_SIZE))
				{
					shoulder_goal = (shoulder_position + GOAL_STEP_SIZE);
					if (shoulder_goal > MAX_SHOULDER)
					{
						shoulder_goal = MAX_SHOULDER;
					}
				}
				else if(shoulder_goal < (MAX_SHOULDER-GOAL_STEP_SIZE))	/* limit check */
				{
					shoulder_goal += GOAL_STEP_SIZE;
				}
			}
			else if(vexRT[Btn5D] == 1)  	//Else, if button 5D is pressed... instruct the shoulder DOWN lower
			{
				if(shoulder_goal > (shoulder_position - GOAL_STEP_SIZE))
				{
					shoulder_goal = (shoulder_position - GOAL_STEP_SIZE);
					if (shoulder_goal < 0)
					{
						shoulder_goal = 0;
					}
				}
				else if(shoulder_goal > GOAL_STEP_SIZE)  /* limit check */
				{
					shoulder_goal -= GOAL_STEP_SIZE;
				}
			}

			/*  Step 2:  Apply the drive based on the goal and error */
			//completely flat=1982 when down
			//up all the way=3584
			//flat up all the way=0

			shoulder_error = shoulder_goal - shoulder_position ;
			shoulder_drive =  shoulder_error * 3;
			if (shoulder_drive > MAX_MOTOR )   /* limit check */
			{
				shoulder_drive = MAX_MOTOR;
			}
			else if (shoulder_drive < MIN_MOTOR ) /* limit check */
			{
				shoulder_drive = MIN_MOTOR;
			}

			/* limit switch  check! */
			if ((shoulder_limit == 1) && (shoulder_drive > 0))
			{
				shoulder_drive = 0;
			}
			/* drive the motor according to the error signal */
			motor[S1] = shoulder_drive ;
			motor[S2] = shoulder_drive ;
		}  // end SHOULDER_MODE_manual  ( position drive with encoder )
		//		else  // shoulder_mode undefined !!!!
		//		{
		//			motor[S1] = 0 ;
		//			motor[S2] = 0 ;
		//			shoulder_mode =  SHOULDER_MODE_test;
		// ToDo  set error mode
		//		}

		/* if we are somehow at the limit - reset the encoder */
		if (shoulder_limit == 1)
		{
			limit_count += 1;
			if (limit_count >= 10)
			{
				SensorValue[shldr_enc] = MAX_SHOULDER;
			}
		}
		else
		{
			limit_count = 0;
		}

		/*************************************************************************
		***************************      claw control    ************************
		*  Test Mode:   normal 'motor control' Btn6U/D controls motor drive up/down
		*        set with button 8R
		*  Manual Mode:  position control:  Btn6U/D controls motor position up/down
		*        set with button 8U
		*  Slave Mode:  position control: shoulder position controls wrist goal
		*        set with button 8D
		*************************************************************************/
#if 0
		if(vexRT[Btn8U] == 1)

motor[BL] = vexRT[Ch2] * -DRIVE_GAIN; // / 1;
			motor[BR] = vexRT[Ch3] * -DRIVE_GAIN; // / 1;
	claw_position = SensorValue[claw_Pot];	 // claw potentiometer goes 0 to 4095
		;
		liftValue = SensorValue[shldr_enc];


		/* drive scissor lift - directly with button 5 U/D */
		if ((vexRT[Btn5U] == 1) && (SensorValue[shldr_enc] < 12345)) /* FIXME - change limit to encoder */
		{
			motor[S1] = 127;
			motor[S2] = 127;
			//			motor[L3] = 127;
		}
		else if (vexRT[Btn5D] == 1)
		{
			motor[S1] = -127;
			motor[S2] = -127;
			//			motor[L3] = -127;
		}
		else
		{
			motor[S1] = 0;
			motor[S2] = 0;
			//			motor[L3] = 0;
		}
#endif
		/***********************************************
		*****************			 claw			**************
		* Use button 6D/U to close/open the claw
		*
		* Use button 8R to put the claw into 'hold' mode
		*	 where it will use the potentiometer to maintain
		*	 the last position when 8R was pressed
		* Claw potentiometer wide open 1400, closed 2780 (Feb 17 2017)
		*********************************************/
		//		if (vexRT[Btn8R] == 1)	/* switch to 'pot' mode */
		//		{
		//			claw_mode =	 CLAW_MODE_pot;
		//			claw_position = SensorValue[ClawPot];
		//			claw_goal = claw_position;	/* actual:	potentiometer reading */
		//			writeDebugStreamLine("claw pot mode: %d", claw_goal);
		//		}
		if (vexRT[Btn8R] == 1)	/* switch to 'hold' mode */
		{
			claw_mode =	 CLAW_MODE_hold;
			motor[C1] = 30;
				motor[C2] = 30;/* ToDo - harder hold torque */
			writeDebugStreamLine("claw hold mode: %d", claw_goal);
		}
		else if (vexRT[Btn8L] == 1) /* switch to 'hold' mode */
		{
			claw_mode =	 CLAW_MODE_hold;
			motor[C1] = 50;
			motor[C2] = 50;/* ToDo - figure out a safe hold torque */
			writeDebugStreamLine("claw hold mode: %d", claw_goal);
		}
		//		else if (vexRT[Btn8U] == 1)	 /* manual drive open 8U */
		else if (vexRT[Btn6D] == 1)	 /* manual drive open 6U */
		{
			motor[C1] = -80;
				motor[C2] = -80;
			claw_mode =	 CLAW_MODE_manual;
		}
		//		else if (vexRT[Btn8D] == 1)	 /* manual drive open 8D */
		else if (vexRT[Btn6U] == 1)	 /* manual drive open 6D */
		{
			motor[C1] = 100;
			motor[C2] = 100;
			claw_mode =	 CLAW_MODE_manual;
		}
		else if (claw_mode == CLAW_MODE_manual)
		{
			motor[C1] = 0;
			motor[C2] = 0;/* ToDo - do we want some hold drive? */
		}
		/*	if hold mode, then use the potentiometer to set the motor drive */
		else if (claw_mode ==	 CLAW_MODE_pot)
		{
			claw_error = (claw_position- claw_goal);
			claw_drive = claw_error / 4;
			if (claw_drive > MAX_MOTOR )	 /* limit check */
			{
				claw_drive = MAX_MOTOR;
			}
			else if (claw_drive < MIN_MOTOR )		/* limit check */
			{
				claw_drive = MIN_MOTOR;
			}
			/* now set the motor drive */
			motor[C1] = claw_drive;
			motor[C2] = claw_drive;

		} // end CLAW_MODE_HOLD

		wait1Msec(20);

	}	 // end while(1)
}	 // end task
task usercontrol()
{
	// User control code here, inside the loop

	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.
	// .....................................................................................

	stopTask(hold_wrist);
	startTask(user_a_bot);
}
