#pragma config(Sensor, in1,    P_wrist,        sensorPotentiometer)
#pragma config(Sensor, in2,    P_shoulder,     sensorPotentiometer)
#pragma config(Motor,  port2,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           S1,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           S2,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           W,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BL,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MAX_GOAL 2265
#define GOAL_STEP_SIZE 25
#define MAX_MOTOR 127
#define MIN_MOTOR -127
#define PARK_WRIST 4095
#define SLAM_WRIST 2790

typedef enum
{
	WRIST_MODE_manual,
	WRIST_MODE_slave,
	WRIST_MODE_lift,
	WRIST_MODE_slam,
  WRIST_MODE_recover,
} WRIST_MODE_t;

   WRIST_MODE_t wrist_mode =  WRIST_MODE_slave;
	short wrist_goal = 3950;
	short shoulder_goal = 500;

task main()

//	int wrist_up = 0;  // keep track of last action up?
	int elbow_up = 0;
	short wrist_position;
	short wrist_error;
	short wrist_drive;

	short shoulder_position;
	short shoulder_error;
	short shoulder_drive;

	while(1 == 1)
	{
		motor[FL] = vexRT[Ch3] / 1;
		motor[FR] = vexRT[Ch2] / 1;
		motor[BL] = vexRT[Ch3] / 1;
		motor[BR] = vexRT[Ch2] / 1;
	//	motor[S1] = vexRT[Btn5U] / Btn5D;
	//	motor[S2] = vexRT[Btn5U] / Btn5D;
//		motor[W] = vexRT[Btn6U] / Btn6D;
		wrist_position = SensorValue[in1];  // wrist potentiometer goes 0 to 4095

		shoulder_position = SensorValue[in2];  // shooulder potentiometer goes 0 to 4095
#if 0
		if(vexRT[Btn5U] == 1)       	//If button 5U is pressed...
		{
			motor[S1] = 127;
			motor[S2] = 127;//...raise the arm.
			elbow_up = 1;
		}
		else if(vexRT[Btn5D] == 1)  	//Else, if button 5D is pressed...
		{
			motor[S1] = -127;
			motor[S2] = -127;  //... drop the arm
			elbow_up = 0;
		}
		else if(elbow_up == 1)  	//Else, if last action was up ... hold
		{
			motor[S1] = 64;
			motor[S2] = 64;  //... hold the arm ?? ( need to close the loop with a potentiometer! )
		}
		else                      		//Else (neither button is pressed)...
		{
			motor[S1] = 0;
			motor[S2] = 0; //...arm is down ... relax
		}


#endif
		//if(vexRT[Btn6U] == 1)       	//If button 5U is pressed...
	//	{
		//	motor[S2] = 127;    	//...raise the arm.
	//	}
	//	else if(vexRT[Btn6D] == 1)  	//Else, if button 5D is pressed...
	//	{
	//		motor[S2] = -127;   	//...lower the arm.
//		}
//		else                      		//Else (neither button is pressed)...
	//	{

	//		motor[S2] = 0;    		//...stop the gripper.
	//	}

#if 0
	if(vexRT[Btn6U])     // == 1)       	//If button 6U is pressed... instruct the wrist UP higher
		{
			//motor[W] = 127;    	//...raise the hand.
			//wrist_up = 1;
		  if(wrist_goal < (MAX_GOAL-GOAL_STEP_SIZE))
		  {
				wrist_goal += GOAL_STEP_SIZE;
			}
		}
	  else if(vexRT[Btn6D] == 1)  	//Else, if button 6D is pressed... instruct the wrist DOWN lower
		{
			//motor[W] = -127;   // ... lower the hand
			//wrist_up = 0;
			if(wrist_goal > GOAL_STEP_SIZE)
			{
				wrist_goal -= GOAL_STEP_SIZE;
			}
		}

#endif
		//	}
		if(vexRT[Btn5U] == 1)     // == 1)       	//If button 5U is pressed... instruct the shoulder UP higher
		{
			//motor[W] = 127;    	//...raise the shoulder.
			//wrist_up = 1;
		  if(shoulder_goal < (MAX_GOAL-GOAL_STEP_SIZE))
		  {
				shoulder_goal += GOAL_STEP_SIZE;
			}
		}
		else if(vexRT[Btn5D] == 1)  	//Else, if button 5D is pressed... instruct the shoulder DOWN lower
		{
			//motor[W] = -127;   // ... lower the shouldershoulder
			//wrist_up = 0;
			if(shoulder_goal > GOAL_STEP_SIZE)
			{
				shoulder_goal -= GOAL_STEP_SIZE;
			}
		}
//		else if(wrist_up == 1)  	//Else, if last action was up, hold
//		{
//			motor[W] = 48;   // ... hold my hand ?? ( need to close the loop with a potentiometer! )
//		}
//		else                      		//Else (neither button is pressed)...
//		{
//		 	motor[W] = 0;    		//...wrist is down ... relax.

if(wrist_mode ==  WRIST_MODE_slave)
{
   wrist_goal = 2200-.98*shoulder_position;
   if
}

if ((Btn6U == 1) && (wrist_mode ==  WRIST_MODE_slave))
{
	 wrist_mode =  WRIST_MODE_manual;
	 wrist_goal = PARK_WRIST;
}
else if ((Btn6D == 1) && (wrist_mode ==  WRIST_MODE_slave))
{
   wrist_mode =  WRIST_MODE_manual;
	 wrist_goal = SLAM_WRIST;
}
else if ((Btn6D == 0) && (Btn6U == 0) && (wrist_mode ==  WRIST_MODE_manual))
{
	 wrist_mode =  WRIST_MODE_slave;
}


//		}

		waitInMilliseconds(20); // delay?

		/* the wrist_position potentiometer will go from 0 to 4095 over 270 degrees of travel
		 * the motor control goes from -127 to + 128
		 * generate an error signal between actual position and 'goal' to control the wrist motor */
		 wrist_error = wrist_goal - wrist_position ;
		if (wrist_error != 0)
		{
				wrist_drive =  wrist_error / 8;
		    if (wrist_drive > MAX_MOTOR )
		    {
					wrist_drive = MAX_MOTOR;
				}
			  else if (wrist_drive < MIN_MOTOR )
			  {
					wrist_drive = MIN_MOTOR;
				}
				/* drive the motor according to the error signal */
				motor[W] = wrist_drive ;
	  }
//completely flat=1982 when down
	  //up all the way=3584
	  //flat up all the way=0
	 shoulder_error = shoulder_goal - shoulder_position ;
		if (shoulder_error != 0)
		{
				shoulder_drive =  shoulder_error / 8;
		    if (shoulder_drive > MAX_MOTOR )
		    {
					shoulder_drive = MAX_MOTOR;
				}
			  else if (shoulder_drive < MIN_MOTOR )
			  {
					shoulder_drive = MIN_MOTOR;
				}
				/* drive the motor according to the error signal */
				motor[S1] = shoulder_drive ;
				motor[S2] = shoulder_drive ;


	  }
	}  // while (1==1)
}

// end task_main

//...lower the arm.
//    ;multi potato drive

//Arm Control
// if(vexRT[Btn6U] == 1)
//{
//  motor[armMotor] = 40;
//}
//  else if(vexRT[Btn6D] == 1)
//{
//    motor[armMotor] = -40;
// }
//  else
//{
//  motor[armMotor] = 0;
